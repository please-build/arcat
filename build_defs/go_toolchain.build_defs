"""Temporary backport until we release a version of Please with support for tags."""

def go_toolchain(name:str, url:str|dict = '', version:str = '', hashes:list = [], visibility:list = ["PUBLIC"],
                 architectures:list=[], strip_srcs:bool=False, tags:list=None):
    """
    Downloads Go and exposes :<name>|go and :<name>|gofmt as entry points. To use this rule add the
    following to your .plzconfig:

    [go]
    GoTool = //.../<name>|go

    Args:
      name (str): Name of the rule.
      url (str | dict): The URL used to download Go. Can be a single string or a dictionary mapping
                        GOOS-GOARCH to URLs i.e. linux-amd64: 'https://...'. Either provide url or version, but not both.
      version (str): The version of Go to download. Go will be downloaded from https://golang.org/dl/...
                     and the rule will use the current platforms GOOS and GOARCH setting. Either provide url or version,
                     but not both.
      hashes (list): A list of possible hashes for the downloaded archive. Optional.
      visibility (list): Visibility specification. Defaults to public.
      architectures (list): Any additional architectures to install in go architecture format e.g. linux_amd64. This
                            rule will automatically install the arch provided through --arch. This is only useful if you
                            want to manually cross-compile parts of the repo but not others.
      strip_srcs (bool): Whether to strip sources from the SDK which can reduce the size of the cached artifacts and
                         improve performance, especially for remote execution. This doesn't work with go_get() however
                         it is recommended to set this to True if you're using go_module() exclusively.
      tags (bool): Build tags to pass when installing the standard library.
    """
    if url and version:
        fail("Either version or url should be provided but not both")

    if version:
        sdk_url = f'https://golang.org/dl/go{version}.{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}.tar.gz'
    else:
        sdk_url = url if isinstance(url, str) else url[f'{CONFIG.HOSTOS}-{CONFIG.HOSTARCH}']

    download = remote_file(
        name = name,
        _tag = 'download',
        url = sdk_url,
        hashes = hashes,
    )

    cmd = 'tar -xf $SRCS && mv go $OUT && chmod +x $OUT/bin/*; rm -rf $OUT/test'
    # If we're targeting another platform, build the std lib for that. We can't use CONFIG.OS as this is always set to
    # the host OS for tools.
    if CONFIG.TARGET_OS != CONFIG.HOSTOS or CONFIG.TARGET_ARCH != CONFIG.HOSTARCH:
        architectures += [f'{CONFIG.TARGET_OS}_{CONFIG.TARGET_ARCH}']

    if architectures and CONFIG.CGO_ENABLED == "1":
        cmd += f" && export CGO_ENABLED={CONFIG.CGO_ENABLED} && export CFLAGS=\"{CONFIG.GO_C_FLAGS}\" && export CC=$TOOLS_CC"

    tag_flag = (' -tags ' + ','.join(tags)) if tags else ''
    for arch in architectures:
        goos, _, goarch = arch.partition("_")
        cmd += f' && (export GOOS={goos} && export GOARCH={goarch} && $OUT/bin/go install{tag_flag} std)'
    if strip_srcs:
        trim_toolchain = "mv $OUT/src src && mkdir $OUT/src && mv src/unsafe $OUT/src/unsafe"
        cmd = f"{cmd} && {trim_toolchain}"

    #TODO(jpoole): Add the option to compile these with -race for the race detector as well. This need to be plumbed
    # through to the go_library rules as well though.
    return build_rule(
        name = name,
        srcs = [download],
        cmd = cmd,
        outs = [name],
        entry_points = {
            'go': f'{name}/bin/go',
            'gofmt': f'{name}/bin/gofmt',
        },
        tools = {
          "CC": [CONFIG.CGO_CC_TOOL],
        } if CONFIG.CGO_ENABLED == "1" else {},
        binary = True,
        visibility = visibility,
        building_description = "Installing...",
    )
